import React, { useRef, useEffect, useState, useMemo } from 'react';

// --- MATH HELPER (Pure Function) ---
// This ensures the Graph and the Table use the exact same logic without needing to sync state
const calculateProjections = (years, inflationRate, annualConsumption, unitCost, scenarios, currentAnnualSpend) => {
  const results = scenarios.map(scenario => {
    let overtakeYear = null;
    let finalCost = 0;
    
    // We simulate year by year (0 to 20) with fine granularity
    const dt = 0.05;
    
    for (let t = 0; t <= years; t += dt) {
      let gridFactor = 1.0;
      
      if (scenario.type === 'grid') gridFactor = 1.0;
      else if (scenario.type === 'max') gridFactor = 0.2;
      else if (scenario.type === 'single') gridFactor = 1 - (scenario.percent / 100);
      else if (scenario.type === 'phased') {
         // Determine active phase
         let activePercent = 0;
         scenario.phases.forEach(p => {
            if (t >= p.year) activePercent = p.percent;
         });
         gridFactor = 1 - (activePercent / 100);
      }

      const yearlyCost = (annualConsumption * gridFactor) * (unitCost * Math.pow(1 + (inflationRate/100), t));
      finalCost = yearlyCost;

      // Overtake Logic
      if (gridFactor < 1.0) {
        // Ignore start noise
        if (yearlyCost >= currentAnnualSpend && overtakeYear === null && t > 0.5) {
          overtakeYear = t;
        }
        // Reset if it dips below again (Phased benefit)
        if (yearlyCost < currentAnnualSpend && overtakeYear !== null) {
          overtakeYear = null;
        }
      }
    }

    return {
      ...scenario,
      overtake: scenario.type === 'grid' ? 0 : overtakeYear,
      finalCost
    };
  });

  return results;
};

const SolarTreadmillGraph = ({ 
  darkMode, 
  inflationRate, 
  annualConsumption, 
  unitCost,
  scenarios // Now receiving fully calculated scenarios
}) => {
  const canvasRef = useRef(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    if (rect.width === 0 || rect.height === 0) return;

    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    
    const ctx = canvas.getContext('2d');
    ctx.scale(dpr, dpr);

    const width = rect.width;
    const height = rect.height;
    const padding = { top: 60, right: 140, bottom: 60, left: 80 };
    const chartWidth = width - padding.left - padding.right;
    const chartHeight = height - padding.top - padding.bottom;

    const years = 20; 
    const currentAnnualSpend = annualConsumption * unitCost;
    
    // Colors
    const colors = {
      bg: darkMode ? '#1F2937' : '#FFFFFF',
      text: darkMode ? '#E5E7EB' : '#374151',
      grid: darkMode ? '#374151' : '#E5E7EB',
      budgetLine: darkMode ? '#F87171' : '#DC2626',
    };

    // Calculate Y-axis scaling
    const maxVal = currentAnnualSpend * 3.5; 
    
    const getY = (value) => {
      return padding.top + chartHeight - (value / maxVal) * chartHeight;
    };

    const getX = (year) => {
      return padding.left + (year / years) * chartWidth;
    };

    const formatCurrency = (val) => {
      if (val >= 1000000) return `R ${(val/1000000).toFixed(1)}m`;
      if (val >= 1000) return `R ${(val/1000).toFixed(0)}k`;
      return `R ${val.toFixed(0)}`;
    };

    // --- DRAWING ---
    ctx.clearRect(0, 0, width, height);
    ctx.fillStyle = colors.bg;
    ctx.fillRect(0, 0, width, height);

    // Grid & Axes
    ctx.beginPath();
    ctx.strokeStyle = colors.grid;
    ctx.lineWidth = 0.5;
    ctx.globalAlpha = 0.3;

    const steps = 6;
    for (let i = 0; i <= steps; i++) {
      const val = (maxVal / steps) * i;
      const y = getY(val);
      ctx.moveTo(padding.left, y);
      ctx.lineTo(width - padding.right, y);
      
      ctx.save();
      ctx.globalAlpha = 1;
      ctx.fillStyle = colors.text;
      ctx.font = '11px Inter, sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText(formatCurrency(val), padding.left - 10, y + 4);
      ctx.restore();
    }
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Budget Line
    const budgetY = getY(currentAnnualSpend);
    ctx.beginPath();
    ctx.strokeStyle = colors.budgetLine;
    ctx.setLineDash([8, 4]);
    ctx.lineWidth = 2;
    ctx.moveTo(padding.left, budgetY);
    ctx.lineTo(width - padding.right, budgetY);
    ctx.stroke();
    ctx.setLineDash([]); 

    ctx.fillStyle = colors.budgetLine;
    ctx.font = 'bold 12px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('CURRENT BUDGET CEILING', width - padding.right + 10, budgetY + 4);

    // Plot Scenarios
    scenarios.forEach((scenario) => {
      // Avoid drawing Max line if Custom is very close to it
      if (scenario.type === 'max' && scenario.hidden) return;

      ctx.beginPath();
      ctx.strokeStyle = scenario.color;
      ctx.lineWidth = scenario.isCustom ? 4 : 2; 
      if (scenario.isCustom) {
         ctx.shadowColor = scenario.color;
         ctx.shadowBlur = 10;
      }

      // Re-run the path logic for drawing (using same logic as projection function)
      // We do this here for pixel-perfect line drawing
      const dt = 0.05;
      for (let t = 0; t <= years; t += dt) {
        let gridFactor = 1.0;
        if (scenario.type === 'grid') gridFactor = 1.0;
        else if (scenario.type === 'max') gridFactor = 0.2;
        else if (scenario.type === 'single') gridFactor = 1 - (scenario.percent / 100);
        else if (scenario.type === 'phased') {
             let activePercent = 0;
             scenario.phases.forEach(p => { if (t >= p.year) activePercent = p.percent; });
             gridFactor = 1 - (activePercent / 100);
        }
        
        const cost = (annualConsumption * gridFactor) * (unitCost * Math.pow(1 + (inflationRate/100), t));
        const x = getX(t);
        const y = getY(cost);

        if (t === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      ctx.shadowBlur = 0; 

      // Label at end
      ctx.fillStyle = scenario.color;
      ctx.textAlign = 'left';
      ctx.font = scenario.isCustom ? 'bold 13px Inter, sans-serif' : '12px Inter, sans-serif';
      
      const textY = Math.min(getY(scenario.finalCost), height - 10);
      const topClamp = Math.max(textY, 20);
      
      if (scenario.finalCost < maxVal * 1.5) { 
          ctx.fillText(scenario.label, width - padding.right + 5, topClamp);
      }

      // Annotate Overtake
      if (scenario.overtake) {
        const x = getX(scenario.overtake);
        const y = budgetY;

        ctx.beginPath();
        ctx.fillStyle = colors.text;
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.strokeStyle = colors.text;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.moveTo(x, y);
        ctx.lineTo(x, height - padding.bottom);
        ctx.stroke();
        ctx.setLineDash([]);

        ctx.textAlign = 'center';
        ctx.fillStyle = colors.text;
        ctx.font = 'bold 12px Inter, sans-serif';
        const yOffset = scenario.isCustom ? 35 : 15;
        ctx.fillText(`${scenario.overtake.toFixed(1)} Yrs`, x, height - padding.bottom + yOffset);
      }
    });

    // X-Axis
    ctx.textAlign = 'center';
    ctx.fillStyle = colors.text;
    ctx.font = '14px Inter, sans-serif';
    ctx.fillText('Years from Implementation', padding.left + chartWidth / 2, height - 15);

    // Title
    ctx.font = 'bold 18px Inter, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText('Projected Operational Costs', padding.left, 35);

  }, [darkMode, inflationRate, annualConsumption, unitCost, scenarios]);

  return (
    <div style={{ width: '100%', height: '500px' }}>
      <canvas ref={canvasRef} style={{ width: '100%', height: '100%' }} />
    </div>
  );
};

export default function App() {
  const [isDarkMode, setIsDarkMode] = useState(false);
  
  // Inputs
  const [inflationRate, setInflationRate] = useState(9.8);
  const [annualConsumption, setAnnualConsumption] = useState(130000);
  const [unitCost, setUnitCost] = useState(5.43);
  const [capexPerKw, setCapexPerKw] = useState(28000); 

  // Strategy Mode
  const [isPhasedMode, setIsPhasedMode] = useState(false);
  
  // Single Strategy State
  const [targetSolar, setTargetSolar] = useState(40);

  // Phased Strategy State
  const [phase1, setPhase1] = useState({ percent: 30, year: 0 });
  const [phase2, setPhase2] = useState({ percent: 50, year: 3 });
  const [phase3, setPhase3] = useState({ percent: 80, year: 6 });

  // --- ANALYSIS CALCULATION (Lifted to Parent) ---
  const analysisData = useMemo(() => {
    const currentAnnualSpend = annualConsumption * unitCost;

    const rawScenarios = [
      { 
        label: 'Do Nothing (100% Grid)', 
        type: 'grid', 
        color: '#EF4444' 
      },
      { 
        label: isPhasedMode ? 'Phased Strategy' : `Proposed (${targetSolar}%)`, 
        type: isPhasedMode ? 'phased' : 'single',
        color: '#3B82F6', 
        isCustom: true,
        percent: targetSolar,
        phases: [phase1, phase2, phase3]
      },
      { 
        label: 'Max Feasible (80%)', 
        type: 'max', 
        color: '#10B981',
        hidden: !isPhasedMode && targetSolar >= 75 || isPhasedMode && phase3.percent >= 75 
      }
    ];

    return calculateProjections(20, inflationRate, annualConsumption, unitCost, rawScenarios, currentAnnualSpend);

  }, [inflationRate, annualConsumption, unitCost, isPhasedMode, targetSolar, phase1, phase2, phase3]);


  // Capex Calculations
  const specificYield = 1550; 
  const getCapexForPercent = (pct) => ((annualConsumption * (pct / 100)) / specificYield) * capexPerKw;

  const singleCapex = getCapexForPercent(targetSolar);
  const p1Capex = getCapexForPercent(phase1.percent);
  const p2Capex = getCapexForPercent(phase2.percent) - getCapexForPercent(phase1.percent);
  const p3Capex = getCapexForPercent(phase3.percent) - getCapexForPercent(phase2.percent);
  const totalPhasedCapex = p1Capex + p2Capex + p3Capex;

  const fmtMoney = (val) => new Intl.NumberFormat('en-ZA', { style: 'currency', currency: 'ZAR', maximumFractionDigits: 0 }).format(val);

  // Helper to determine risk status safely
  const getRiskStatus = (row) => {
    if (row.label.includes('Do Nothing')) {
        return { text: 'UNSUSTAINABLE', color: 'text-red-500 font-bold' };
    }
    if (!row.overtake || row.overtake === 0) {
        return { text: 'Strategic Asset: Long-term stability.', color: 'text-green-500 font-bold' };
    }
    if (row.overtake < 5) return { text: 'Critical Risk: Short-term fix only.', color: 'text-orange-500' };
    if (row.overtake < 10) return { text: 'Moderate Risk: Buys medium-term time.', color: 'text-blue-500' };
    
    return { text: 'Strategic Asset: Long-term stability.', color: 'text-green-500 font-bold' };
  };

  return (
    <div className={`min-h-screen p-6 md:p-10 transition-colors duration-300 ${isDarkMode ? 'bg-gray-900 text-white' : 'bg-gray-50 text-gray-900'}`}>
      
      {/* Header */}
      <div className="flex flex-col md:flex-row justify-between items-start md:items-center mb-8 gap-4">
        <div>
           <h1 className="text-3xl font-bold tracking-tight">Solar Strategy Simulator</h1>
           <p className={`mt-1 ${isDarkMode ? 'text-gray-400' : 'text-gray-600'}`}>
             Interactive Budget & Capex Analysis
           </p>
        </div>
        
        <button
          onClick={() => setIsDarkMode(!isDarkMode)}
          className={`px-4 py-2 rounded-lg font-medium text-sm transition-all ${
            isDarkMode 
              ? 'bg-gray-800 hover:bg-gray-700 text-white border border-gray-700' 
              : 'bg-white hover:bg-gray-100 text-gray-900 border border-gray-300 shadow-sm'
          }`}
        >
          {isDarkMode ? '‚òÄÔ∏è Light' : 'üåô Dark'}
        </button>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-12 gap-6">
        
        {/* Controls Sidebar */}
        <div className={`lg:col-span-3 p-6 rounded-xl border h-fit space-y-6 ${isDarkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200 shadow-sm'}`}>
          <h2 className="font-semibold text-lg flex items-center gap-2 text-blue-500">
            1. Current Status
          </h2>
          
          <div>
            <label className="block text-xs font-medium uppercase tracking-wider mb-1 opacity-70">Annual Consumption (kWh)</label>
            <input 
              type="number" 
              value={annualConsumption}
              onChange={(e) => setAnnualConsumption(Number(e.target.value))}
              className={`w-full p-2 rounded-md border text-lg font-mono ${isDarkMode ? 'bg-gray-900 border-gray-600' : 'bg-gray-50 border-gray-300'}`}
            />
          </div>

          <div>
            <label className="block text-xs font-medium uppercase tracking-wider mb-1 opacity-70">Avg Cost per kWh (R)</label>
            <input 
              type="number" 
              step="0.01"
              value={unitCost}
              onChange={(e) => setUnitCost(Number(e.target.value))}
              className={`w-full p-2 rounded-md border text-lg font-mono ${isDarkMode ? 'bg-gray-900 border-gray-600' : 'bg-gray-50 border-gray-300'}`}
            />
          </div>

          <div>
            <label className="block text-xs font-medium uppercase tracking-wider mb-1 opacity-70">Grid Inflation (% p.a.)</label>
            <div className="flex items-center gap-2">
                <input 
                  type="range" 
                  min="0" 
                  max="20" 
                  step="0.1"
                  value={inflationRate}
                  onChange={(e) => setInflationRate(Number(e.target.value))}
                  className="flex-grow h-2 rounded-lg appearance-none cursor-pointer bg-red-500"
                />
                <span className="font-mono w-12 text-right">{inflationRate}%</span>
            </div>
          </div>

          <hr className={`border-t ${isDarkMode ? 'border-gray-700' : 'border-gray-200'}`} />

          <div className="flex justify-between items-center">
             <h2 className="font-semibold text-lg flex items-center gap-2 text-green-500">
                2. Solar Strategy
             </h2>
             <div className="flex items-center gap-2 text-xs">
                <span>Single</span>
                <button 
                  onClick={() => setIsPhasedMode(!isPhasedMode)}
                  className={`w-10 h-5 rounded-full p-1 transition-colors ${isPhasedMode ? 'bg-green-500' : 'bg-gray-400'}`}
                >
                    <div className={`bg-white w-3 h-3 rounded-full shadow-md transform transition-transform ${isPhasedMode ? 'translate-x-5' : 'translate-x-0'}`}></div>
                </button>
                <span>Phased</span>
             </div>
          </div>

          {!isPhasedMode ? (
              // SINGLE MODE INPUTS
              <div>
                <label className="block text-xs font-medium uppercase tracking-wider mb-1 opacity-70">Target Capacity (%)</label>
                <div className="flex items-center gap-2 mb-2">
                    <input 
                      type="range" 
                      min="10" 
                      max="90" 
                      step="5"
                      value={targetSolar}
                      onChange={(e) => setTargetSolar(Number(e.target.value))}
                      className="flex-grow h-2 rounded-lg appearance-none cursor-pointer bg-green-500"
                    />
                    <span className="font-mono w-12 text-right text-green-500 font-bold">{targetSolar}%</span>
                </div>
                <div className={`p-4 mt-4 rounded-lg text-sm border ${isDarkMode ? 'bg-gray-700/30 border-green-900/50' : 'bg-green-50 text-green-900 border-green-200'}`}>
                    <p className="font-bold mb-1 opacity-80">REQUIRED CAPEX:</p>
                    <p className="text-2xl font-mono font-bold text-green-500">{fmtMoney(singleCapex)}</p>
                </div>
              </div>
          ) : (
              // PHASED MODE INPUTS
              <div className="space-y-4">
                  {/* Phase 1 */}
                  <div className={`p-3 rounded border ${isDarkMode ? 'border-gray-700 bg-gray-800' : 'border-gray-200 bg-gray-50'}`}>
                      <div className="flex justify-between text-xs font-bold mb-2">
                          <span>PHASE 1 (Year {phase1.year})</span>
                          <span className="text-green-500">{phase1.percent}% Total</span>
                      </div>
                      <input 
                        type="range" min="10" max={phase2.percent - 5} step="5"
                        value={phase1.percent}
                        onChange={(e) => setPhase1({...phase1, percent: Number(e.target.value)})}
                        className="w-full h-2 rounded-lg appearance-none cursor-pointer bg-green-500 mb-1"
                      />
                      <div className="text-right text-xs font-mono opacity-70">{fmtMoney(p1Capex)}</div>
                  </div>

                  {/* Phase 2 */}
                  <div className={`p-3 rounded border ${isDarkMode ? 'border-gray-700 bg-gray-800' : 'border-gray-200 bg-gray-50'}`}>
                      <div className="flex justify-between text-xs font-bold mb-2">
                          <span>PHASE 2 (Year {phase2.year})</span>
                          <span className="text-green-500">{phase2.percent}% Total</span>
                      </div>
                      <div className="flex gap-2 mb-2">
                          <input 
                            type="range" min={phase1.percent + 5} max={phase3.percent - 5} step="5"
                            value={phase2.percent}
                            onChange={(e) => setPhase2({...phase2, percent: Number(e.target.value)})}
                            className="flex-grow h-2 rounded-lg appearance-none cursor-pointer bg-green-500"
                          />
                          <input 
                             type="number" min="1" max="10" 
                             value={phase2.year}
                             onChange={(e) => setPhase2({...phase2, year: Number(e.target.value)})}
                             className={`w-12 text-center rounded text-xs ${isDarkMode?'bg-gray-900':'bg-white'}`}
                          />
                      </div>
                      <div className="text-right text-xs font-mono opacity-70">Add: {fmtMoney(p2Capex)}</div>
                  </div>

                   {/* Phase 3 */}
                   <div className={`p-3 rounded border ${isDarkMode ? 'border-gray-700 bg-gray-800' : 'border-gray-200 bg-gray-50'}`}>
                      <div className="flex justify-between text-xs font-bold mb-2">
                          <span>PHASE 3 (Year {phase3.year})</span>
                          <span className="text-green-500">{phase3.percent}% Total</span>
                      </div>
                      <div className="flex gap-2 mb-2">
                          <input 
                            type="range" min={phase2.percent + 5} max="95" step="5"
                            value={phase3.percent}
                            onChange={(e) => setPhase3({...phase3, percent: Number(e.target.value)})}
                            className="flex-grow h-2 rounded-lg appearance-none cursor-pointer bg-green-500"
                          />
                          <input 
                             type="number" min={phase2.year + 1} max="15" 
                             value={phase3.year}
                             onChange={(e) => setPhase3({...phase3, year: Number(e.target.value)})}
                             className={`w-12 text-center rounded text-xs ${isDarkMode?'bg-gray-900':'bg-white'}`}
                          />
                      </div>
                      <div className="text-right text-xs font-mono opacity-70">Add: {fmtMoney(p3Capex)}</div>
                  </div>
              </div>
          )}

          <div>
            <label className="block text-xs font-medium uppercase tracking-wider mb-1 opacity-70">Est. Install Cost (R/kWp)</label>
            <input 
              type="number" 
              value={capexPerKw}
              onChange={(e) => setCapexPerKw(Number(e.target.value))}
              className={`w-full p-2 rounded-md border text-sm font-mono ${isDarkMode ? 'bg-gray-900 border-gray-600' : 'bg-gray-50 border-gray-300'}`}
            />
          </div>

        </div>

        <div className="lg:col-span-9 space-y-6">
            {/* Graph Area */}
            <div className={`rounded-xl overflow-hidden border shadow-sm relative ${isDarkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200'}`}>
            <SolarTreadmillGraph 
                darkMode={isDarkMode} 
                inflationRate={inflationRate}
                annualConsumption={annualConsumption}
                unitCost={unitCost}
                scenarios={analysisData} // Passing fully computed data
            />
            </div>

            {/* Assumptions Panel */}
            <div className={`p-4 rounded-lg border text-sm ${isDarkMode ? 'bg-gray-800 border-gray-700 text-gray-300' : 'bg-blue-50 border-blue-200 text-blue-900'}`}>
                <h4 className="font-bold mb-2 flex items-center gap-2">
                    ‚ÑπÔ∏è Strategy Guide
                </h4>
                <ul className="grid grid-cols-1 md:grid-cols-2 gap-4 list-disc pl-5">
                    <li>
                        <strong>Phased Implementation:</strong> Adding capacity in Year 3 or Year 6 "resets" the inflation clock. The graph drops vertically when new panels come online.
                    </li>
                    <li>
                        <strong>Overtake Period:</strong> Notice how a Phased Strategy pushes the "Overtake Year" (dot) much further to the right than a single small install.
                    </li>
                    <li>
                        <strong>Capex Planning:</strong> The "Add" amounts in the sidebar show the specific funding required for that specific AGM year (calculated at today's prices).
                    </li>
                </ul>
            </div>

            {/* Analysis Table */}
            <div className={`rounded-xl border p-6 ${isDarkMode ? 'bg-gray-800 border-gray-700' : 'bg-white border-gray-200 shadow-sm'}`}>
                <h3 className="text-lg font-bold mb-4">Strategic Impact Analysis</h3>
                <div className="overflow-x-auto">
                    <table className="w-full text-left border-collapse">
                        <thead>
                            <tr className={`border-b text-xs uppercase tracking-wider ${isDarkMode ? 'border-gray-700 text-gray-400' : 'border-gray-200 text-gray-500'}`}>
                                <th className="p-3">Scenario</th>
                                <th className="p-3">Total Capex</th>
                                <th className="p-3">Overtake Period <br/><span className="normal-case opacity-75 font-normal">(Years until bill returns to current levels)</span></th>
                                <th className="p-3">Strategy Assessment</th>
                            </tr>
                        </thead>
                        <tbody className="font-medium">
                            {analysisData.map((row, i) => {
                                const status = getRiskStatus(row);
                                // Skip drawing "Max" row in table if it's redundant/hidden
                                if (row.hidden) return null;

                                return (
                                    <tr key={i} className={`border-b last:border-0 hover:bg-opacity-50 ${isDarkMode ? 'border-gray-700 hover:bg-gray-700' : 'border-gray-100 hover:bg-gray-50'}`}>
                                        <td className="p-3 flex items-center gap-2">
                                            <span className="w-3 h-3 rounded-full" style={{backgroundColor: row.color}}></span>
                                            {row.label}
                                        </td>
                                        <td className="p-3 font-mono text-sm opacity-80">
                                            {row.label.includes('Do Nothing') ? '-' : 
                                             row.label.includes('Phased') ? fmtMoney(totalPhasedCapex) :
                                             row.label.includes('Max') ? fmtMoney(getCapexForPercent(80)) :
                                             fmtMoney(singleCapex)}
                                        </td>
                                        <td className="p-3 font-mono text-lg">
                                            {row.label.includes('Do Nothing') ? 'N/A' :
                                             (!row.overtake || row.overtake === 0) ? '17+ Years' : 
                                             `${row.overtake.toFixed(1)} Years`}
                                        </td>
                                        <td className={`p-3 text-sm ${status.color}`}>
                                            {status.text}
                                        </td>
                                    </tr>
                                );
                            })}
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

      </div>
    </div>
  );
}